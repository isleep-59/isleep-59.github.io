<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/27/hello-world/</url>
    <content><![CDATA[<p>记录一下博客建成哩！</p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>上下车问题</title>
    <url>/2022/07/31/%E4%B8%8A%E4%B8%8B%E8%BD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n-1站），都满足此规律。</p>
<p>现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？</p>
<p>若无解则输出“No answer.”</p>
<span id="more"></span>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>包含多组测试数据，每组测试数据占一行，包括a，n，m和x四个数，其中0&lt;&#x3D;a，m&lt;&#x3D;100000&lt;n，x&lt;&#x3D;20</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据占一行，输出一个数x，即站开出时车上的人数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 6 7 3</span><br><span class="line">5 7 32 4</span><br></pre></td></tr></table></figure>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">13</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本质其实就是斐波那契数列，由于每次上下车人数的计算方式不同，我选择开两个数组stops_up和stops_down，前者用来存上车人数，后者用来存下车人数；</p>
<p>上车人数的递推式为<code> stops_up[j] = stops_up[j - 1] + stops_up[j - 2];</code></p>
<p>下车人数的递推式为<code>stops_down[j] = stops_up[j-1];</code></p>
<p>由于这道题是只知道最后的下车人数但是不知道第二次的上下车人数，我决定用暴力一个个搜，即把每一种第二次上车人数的情况都给枚举出来，然后把第n-1站的人数与m比对（第m站是所有人都下车，所以m &#x3D;&#x3D; 第n-1站开出时车上的人数），如果相等则输出第x站开出时车上人数，否则无解；</p>
<p>下面是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> start, n, m, x;</span><br><span class="line"><span class="type">int</span> stops_up[MAX], stops_down[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; start &gt;&gt; n &gt;&gt; m &gt;&gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> judge = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        stops_up[<span class="number">0</span>] = start;</span><br><span class="line">        stops_down[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> summ = start, sumx = start;</span><br><span class="line">            </span><br><span class="line">            stops_up[<span class="number">1</span>] = i;</span><br><span class="line">            stops_down[<span class="number">1</span>] = i;            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                stops_up[j] = stops_up[j - <span class="number">1</span>] + stops_up[j - <span class="number">2</span>];</span><br><span class="line">                stops_down[j] = stops_up[j - <span class="number">1</span>];</span><br><span class="line">                summ += stops_up[j] - stops_down[j];	<span class="comment">//计算第j站开出时车上人数</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (j == x - <span class="number">1</span>)</span><br><span class="line">                    sumx = summ;	<span class="comment">//记录下第x站开出时车上人数</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (summ == m)</span><br><span class="line">            &#123;</span><br><span class="line">                judge = <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; sumx &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!judge)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No answer.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title>回型矩阵</title>
    <url>/2022/08/01/%E5%9B%9E%E5%9E%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>输出n*m的回型矩阵</p>
<span id="more"></span>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>多组测试数据<br>每组输入2个整数 n和m(不大于20)  </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出n*m的回型矩阵，要求左上角元素是1，（每个元素占2个位置，靠右） </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br></pre></td></tr></table></figure>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1  2  3</span><br><span class="line">10 11  4</span><br><span class="line"> 9 12  5</span><br><span class="line"> 8  7  6</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><pre><code>简单模拟题，只用模拟出四个方向即可，我选择开一个二维数组dir用来表示四个方向；

在模拟过程中需要注意的问题有两个，一个是重复填数，一个是填数填到了矩阵外面，为了避免这两种情况，我在一开始将数组初始化为0，并在填数时判断当前访问单元是否越界以及是否为0（填数从1开始，所以已经被填过数的单元不为0），最后在填了n*m后break就好；
</code></pre>
<p>下面是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">-1</span>, <span class="number">-1</span>,<span class="number">0</span>&#125;;		<span class="comment">//四个方向按顺序存入</span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInMap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n &amp;&amp; !Map[i][j]) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> &amp;nowi, <span class="type">int</span> &amp;nowj, <span class="type">int</span> &amp;now, <span class="type">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mms</span>(Map);</span><br><span class="line">    Map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    nowi = <span class="number">0</span>;</span><br><span class="line">    nowj = <span class="number">0</span>;</span><br><span class="line">    now = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nowi, nowj, now, num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(nowi, nowj, now, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= m * n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isInMap</span>(nowi + dir[now][<span class="number">0</span>], nowj + dir[now][<span class="number">1</span>]))	<span class="comment">//若满足条件则填数</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowi += dir[now][<span class="number">0</span>];</span><br><span class="line">                nowj += dir[now][<span class="number">1</span>];</span><br><span class="line">                Map[nowi][nowj] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//若不满足条件就转向</span></span><br><span class="line">                now = ++now % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d%c&quot;</span>, Map[i][j], ((j == n - <span class="number">1</span>) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这道题还有另外一种解法（via. GZW）：</p>
<pre><code>这题也可以用4个变量来记录边界位置，然后在1个大循环里面套4个小循环并在每次小循环后压缩边界来实现上面的方向模拟，若出现了边界越界则模拟结束；

这里面有一个小细节在于，边界变量同时作为方向模拟的初始值以及模拟结束的判断值，使得代码相对简洁；
</code></pre>
<p>下面是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num[n][m];</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bot = n - <span class="number">1</span>, lef = <span class="number">0</span>, rig = m - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= m * n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = lef; i &lt;= rig; i++)</span><br><span class="line">                num[top][i] = cnt++;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = top; i &lt;= bot; i++)</span><br><span class="line">                num[i][rig] = cnt++;</span><br><span class="line">            rig--;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = rig; i &gt;= lef; i--)</span><br><span class="line">                num[bot][i] = cnt++;</span><br><span class="line">            bot--;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = bot; i &gt;= top; i--)</span><br><span class="line">                num[i][lef] = cnt++;</span><br><span class="line">            lef++;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;%2d%c&quot;</span>, num[i][j], ((j == m - <span class="number">1</span>) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>求N的阶乘</title>
    <url>/2022/08/01/%E6%B1%82N%E7%9A%84%E9%98%B6%E4%B9%98/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>用递归算法，求N！的精确值(N以一般整数输入,N&lt;100)。</p>
<span id="more"></span>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入一个整数n</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出n！</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10!=3628800</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然100数据规模的阶乘是无法用longlong存下的，所以我选择用数组来模拟大数乘法，具体代码实现是从社团学姐那里学到的，这里附上我的理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>], endn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bignum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;		<span class="comment">//如果递归到1即阶乘结束</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;		<span class="comment">//temp用来存每位数做乘法之后多出来的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= endn; i++)		<span class="comment">//endn用来表示当前数组长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[i] = num[i] * n + temp;		<span class="comment">//当前位数先与n做乘法并加上上一位进位的数temp</span></span><br><span class="line">        temp = num[i] / <span class="number">10</span>;		<span class="comment">//进位的temp是当前位数与n的乘积减去个位数（数组一个单元只存一位数）</span></span><br><span class="line">        num[i] %= <span class="number">10</span>;		<span class="comment">//将乘积的个位数存进数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp)		<span class="comment">//如果乘完了但是temp不为0，则还需要进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[++endn] = temp % <span class="number">10</span>;		<span class="comment">//endn需要向后扩张以保存temp</span></span><br><span class="line">        temp /= <span class="number">10</span>;			<span class="comment">//temp需要一位一位的存进数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bignum</span>(n - <span class="number">1</span>);		<span class="comment">//递归继续与n-1相乘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">mms</span>(num);</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//这里有个细节，数组的第一位需要初始化为1，否则结果将为0</span></span><br><span class="line">        <span class="built_in">Bignum</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d!=&quot;</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = endn; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            cout &lt;&lt; num[i];		<span class="comment">//逆向输出数组</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始发现long long不够用的时候，我第一反应也是用数组来模拟乘法，但是当时脑子里一直想的都是列竖式计算的时候的进位方法，也就是一位一位的去跟所有数乘，然后每次只会进一位。在看了学姐的代码之后才恍然大悟，可以每次直接用n去和数组的每一位数字相乘，多出来的数全部进位就好，不用顾忌“进位的数有好几位怎么办”这样愚蠢的问题。。。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>高精度计算</tag>
      </tags>
  </entry>
</search>
