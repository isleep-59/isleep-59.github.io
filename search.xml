<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/27/hello-world/</url>
    <content><![CDATA[<p>置顶留言板，欢迎留言捏</p>
<span id="more"></span>

<p>记录一下博客建成哩！</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构课设-财务报销管理系统</title>
    <url>/2022/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE/</url>
    <content><![CDATA[<h1 id="财务报销管理系统"><a href="#财务报销管理系统" class="headerlink" title="财务报销管理系统"></a>财务报销管理系统</h1><p>公司日常费用的财务报销管理，对于每个公司而言，是非常重要的管理节点。如何设计合理的数据结构、数据处理流程提升财务报销效率，是一个非常值得探索的问题。针对日常报销需求，开发一个简易的财务报销管理系统。</p>
<span id="more"></span>

<h2 id="1-数据格式"><a href="#1-数据格式" class="headerlink" title="1. 数据格式"></a>1. 数据格式</h2><p>采用多文件存储数据，文件内容与标题对应：</p>
<ol>
<li><p>文件一（申请人信息）：	</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//employee.txt</span><br><span class="line">工号            姓名          手机号              </span><br><span class="line">005            张三           13900700700         </span><br><span class="line">006            李四           13900800800     </span><br></pre></td></tr></table></figure>

</li>
<li><p>文件二（处理人信息）：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//manager.txt</span><br><span class="line">工号          姓名          手机号              职位                </span><br><span class="line">001           王五          13300100100         部门副主管          </span><br><span class="line">002           赵一          13900200200         财务副主管          </span><br><span class="line">003           孙六          13800400100         部门主管            </span><br><span class="line">004           钱七          13900300200         财务主管            </span><br></pre></td></tr></table></figure>

</li>
<li><p>文件三（额度限制信息）：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//quota.txt</span><br><span class="line">工号            职位                最大额度            </span><br><span class="line">001            部门副主管          50000               </span><br><span class="line">002            财务副主管          50000               </span><br><span class="line">003            部门主管            100000              </span><br><span class="line">004            财务主管            100000              </span><br></pre></td></tr></table></figure>

</li>
<li><p>文件四（流程日志信息）：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//log.txt</span><br><span class="line">报销单编号      提单人      提单金额      提单日期         状态        处理人</span><br><span class="line">20220006       007        100000       20220313       创建</span><br><span class="line">20220007       007        100000       20220313       审批未通过    003</span><br><span class="line">20220008       007        100000       20220313       创建</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-数据结构（读文件创建哈希表与队列）"><a href="#2-数据结构（读文件创建哈希表与队列）" class="headerlink" title="2. 数据结构（读文件创建哈希表与队列）"></a>2. 数据结构（读文件创建哈希表与队列）</h2><p>将文件中的数据读入内存，采用方法为<code>freopen()</code>函数，对程序的io流进行重定向，定向至文件路径所指处读取数据；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：EmployeeMap的数据输入</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;employee.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">string number, name, phone;	</span><br><span class="line">cin &gt;&gt; number_title &gt;&gt; name_title &gt;&gt; phone_title;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; number &gt;&gt; name &gt;&gt; phone) &#123;</span><br><span class="line">    <span class="function">Employee <span class="title">tmp</span><span class="params">(number, name, phone)</span></span>;</span><br><span class="line">    <span class="built_in">add</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;CON&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">cin.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>之后建立以字符串工号为键值的哈希表<code>EmployeeMap</code>，<code>ManagerMap</code>，<code>QuotaMap</code>，然后建立申请人报销循环队列<code>LogQueue</code>以及<code>LogSave</code>，其内部数据成员如下：</p>
<ol>
<li><p>Employee类与EmployeeMap类：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string number, name, phone;</span><br><span class="line">    <span class="comment">//number为工号，name为姓名，phone为手机号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> vis[MAX_SIZE];			<span class="comment">//记录工号是否存在</span></span><br><span class="line">	Employee mp[MAX_SIZE];		<span class="comment">//哈希表</span></span><br><span class="line">	string number_title, name_title, phone_title;	<span class="comment">//用来保存文件输出的表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Manager类与ManagerMap类：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> : <span class="keyword">public</span> Employee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string job;</span><br><span class="line">    <span class="comment">//继承Employee类中数据成员，job为职位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ManagerMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> vis[MAX_SIZE];			<span class="comment">//记录工号是否存在</span></span><br><span class="line">	Manager mp[MAX_SIZE];		<span class="comment">//哈希表</span></span><br><span class="line">	string number_title, name_title, phone_title, job_title;	<span class="comment">//用来保存文件输出的表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Quota类与QuotaMap类；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quota</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string number, job;	<span class="comment">//number为工号，job为职位</span></span><br><span class="line">	<span class="type">int</span> limits;	<span class="comment">//limits为额度限制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuotaMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> vis[MAX_SIZE];		<span class="comment">//记录工号是否存在</span></span><br><span class="line">	Quota mp[MAX_SIZE];		<span class="comment">//哈希表</span></span><br><span class="line">	string number_title, job_title, limits_title;	<span class="comment">//用来保存文件输出的表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>Log类、LogQueue类与LogSave类；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	SYSTEMTIME date;	<span class="comment">//使用Window.h头文件中的SYSTEMTIME变量，可以获取当前系统时间</span></span><br><span class="line">	string employee, manager, status;	<span class="comment">//employee为申请人工号，manager为处理人工号，status为当前处理状态</span></span><br><span class="line">	<span class="type">int</span> money;	<span class="comment">//money为申请报销金额</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Log* q;		<span class="comment">//Log类指针作为队列的数组名</span></span><br><span class="line">	<span class="type">int</span> head, rear;	<span class="comment">//head为队首，rear为队尾</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该类用于保存审批流程至日志中，便于最后的打印展示</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogSave</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Log* q;		<span class="comment">//Log类指针作为队列的数组名</span></span><br><span class="line">	<span class="type">int</span> head, rear, index;		<span class="comment">//head为队首，rear为队尾，index为</span></span><br><span class="line">	string index_title, employee_title, money_title, date_title, status_title, manager_title;	<span class="comment">//保存数据表头</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-编辑文件信息"><a href="#3-编辑文件信息" class="headerlink" title="3. 编辑文件信息"></a>3. 编辑文件信息</h2><p>实现文件的增删改查，设计思路与代码如下：</p>
<ol>
<li><p>哈希函数：使用<code>&lt;string&gt;</code>头文件中的<code>stoi</code>函数作为哈希函数，功能为将字符串转化为其对应的整型数据，由于工号为一一对应的分配，即独一无二的，所以哈希冲突非常低；</p>
</li>
<li><p>信息增加：先将字符串哈希为整数类型，<strong>然后在<code>vis</code>数组中查看该工号是否已经出现过（数据关联性）</strong>，若出现过则返回<code>false</code>且不存入哈希表中，反之保存；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(xxx tmp)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> idx = <span class="built_in">stoi</span>(tmp.<span class="built_in">getNumber</span>());</span><br><span class="line">	<span class="keyword">if</span> (!vis[idx])</span><br><span class="line">		vis[idx] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	mp[idx] = tmp;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息删除：与信息增加相反，如果<code>vis</code>中不存在，则返回<code>false</code>，反之删除；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以工号为索引删除信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">del</span><span class="params">(string number)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> idx = <span class="built_in">stoi</span>(number);</span><br><span class="line">	<span class="keyword">if</span> (vis[idx])</span><br><span class="line">		vis[idx] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息更改：先将要更改的数据从哈希表中删除，然后将更改后的数据添加进表中即可；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以工号为索引更改信息</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">modify</span><span class="params">(string number, Manager tmp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">del</span>(number))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">add</span>(tmp);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息查询：哈希后直接返回表中键值对应的数据；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以工号为索引查询信息</span></span><br><span class="line"><span class="function">xxx <span class="title">query</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mp[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信息更新：在程序运行结束后，将内存中修改过的数据信息重新写入文件中，同样采用了<code>freopen()</code>函数，将输出流定向至文件所在位置：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;employee.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    employee_map.<span class="built_in">display</span>();</span><br><span class="line">    cout.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;manager.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    manager_map.<span class="built_in">display</span>();</span><br><span class="line">    cout.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;quota.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    quota_map.<span class="built_in">display</span>();</span><br><span class="line">    cout.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;log.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    log_save.<span class="built_in">display</span>();</span><br><span class="line">    cout.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;CON&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>*<strong>数据关联性</strong>：</p>
<ol>
<li>当录入的信息中出现非期望的重复时，程序将提示错误然后返回上层菜单，并不将该次输入存入内存中；</li>
<li>ManagerMap类与QuotaMap类中存在信息关联，所以不得直接单项更改或删除上述两类的数据，即ManagerMap类的删改同时要配合QuotaMap类的删改；</li>
</ol>
<h2 id="4-处理报销信息"><a href="#4-处理报销信息" class="headerlink" title="4. 处理报销信息"></a>4. 处理报销信息</h2><h3 id="4-1-在用户交互界面中："><a href="#4-1-在用户交互界面中：" class="headerlink" title="4.1 在用户交互界面中："></a>4.1 在用户交互界面中：</h3><p>首先在菜单中选择<code>7.报销申请</code>，按下回车后即可进入数据录入阶段：</p>
<p><img src="C:\Users\WSSSJ\AppData\Roaming\Typora\typora-user-images\image-20220314172327587.png" alt="image-20220314172327587"></p>
<p>在数据录入阶段，需要输入报销申请人的工号以及期望报销的金额：</p>
<p><img src="C:\Users\WSSSJ\AppData\Roaming\Typora\typora-user-images\image-20220314172515739.png" alt="image-20220314172515739"></p>
<p>如果申请人工号并不存在，则会显示申请失败并返回上层菜单：</p>
<p><img src="C:\Users\WSSSJ\AppData\Roaming\Typora\typora-user-images\image-20220314172616457.png" alt="image-20220314172616457"></p>
<p>反之申请成功：</p>
<p><img src="C:\Users\WSSSJ\AppData\Roaming\Typora\typora-user-images\image-20220314172638927.png" alt="image-20220314172638927"></p>
<h3 id="4-2-在程序后台运行中："><a href="#4-2-在程序后台运行中：" class="headerlink" title="4.2 在程序后台运行中："></a>4.2 在程序后台运行中：</h3><p>对报销申请处理的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string number;</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入申请人的工号：&quot;</span>; cin &gt;&gt; number;</span><br><span class="line"><span class="type">int</span> idx = <span class="built_in">stoi</span>(number);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入报销金额：&quot;</span>; cin &gt;&gt; money;</span><br><span class="line"><span class="function">Log <span class="title">tmp</span><span class="params">(number, money)</span></span>;</span><br><span class="line">log_queue.<span class="built_in">push</span>(tmp);</span><br><span class="line"><span class="built_in">process</span>();</span><br><span class="line"><span class="built_in">tips</span>();</span><br><span class="line"><span class="keyword">if</span> (employee_map.<span class="built_in">check</span>(idx))</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;报销申请成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;报销申请失败，该工号不存在！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fin</span>())</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>当程序收到了来自前端的数据输入之后，会将其压入队列<code>log_queue</code>中，并调用<code>process</code>函数进行处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小trick，获取一个随机状态，状态根据生成数字的奇偶而定</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">2</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当队列不为空时</span></span><br><span class="line">    <span class="keyword">while</span> (!log_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//取出队首将其压入log_save中作为日志内容，并进行下一步操作</span></span><br><span class="line">        Log tmp = log_queue.<span class="built_in">front</span>();</span><br><span class="line">        log_queue.<span class="built_in">pop</span>();</span><br><span class="line">        log_save.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="comment">//如果当前状态是“创建”，则将移交给“部门主/副主管”进行审批</span></span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">getStatus</span>() == <span class="string">&quot;创建&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">//在哈希表中线性查找，复杂度O(n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quota_map.<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">                    Quota quota = quota_map.<span class="built_in">query</span>(i);</span><br><span class="line">                    <span class="comment">//根据申报数额决定分配给主管或者副主管</span></span><br><span class="line">                    <span class="keyword">if</span> (quota.<span class="built_in">getLimits</span>() &gt;= tmp.<span class="built_in">getMoney</span>() &amp;&amp; (quota.<span class="built_in">getJob</span>() == <span class="string">&quot;部门主管&quot;</span> || quota.<span class="built_in">getJob</span>() == <span class="string">&quot;部门副主管&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">//如果审批通过</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">getRandom</span>()) &#123;</span><br><span class="line">                            <span class="comment">//将其当前状态更改</span></span><br><span class="line">                            tmp.<span class="built_in">changeStatus</span>(<span class="string">&quot;部门审批&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            tmp.<span class="built_in">changeStatus</span>(<span class="string">&quot;审批未通过&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将其处理人的信息更新为刚才审批人的信息</span></span><br><span class="line">                        tmp.<span class="built_in">changeManager</span>(quota.<span class="built_in">getNumber</span>());</span><br><span class="line">                        <span class="comment">//再次压入队中</span></span><br><span class="line">                        log_queue.<span class="built_in">push</span>(tmp);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下步骤与上相同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp.<span class="built_in">getStatus</span>() == <span class="string">&quot;部门审批&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quota_map.<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">                    Quota quota = quota_map.<span class="built_in">query</span>(i);</span><br><span class="line">                    <span class="keyword">if</span> (quota.<span class="built_in">getLimits</span>() &gt;= tmp.<span class="built_in">getMoney</span>() &amp;&amp; (quota.<span class="built_in">getJob</span>() == <span class="string">&quot;财务主管&quot;</span> || quota.<span class="built_in">getJob</span>() == <span class="string">&quot;财务副主管&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">getRandom</span>()) &#123;</span><br><span class="line">                            tmp.<span class="built_in">changeStatus</span>(<span class="string">&quot;财务审批&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            tmp.<span class="built_in">changeStatus</span>(<span class="string">&quot;审批未通过&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        tmp.<span class="built_in">changeManager</span>(quota.<span class="built_in">getNumber</span>());</span><br><span class="line">                        log_queue.<span class="built_in">push</span>(tmp);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tmp.<span class="built_in">getStatus</span>() == <span class="string">&quot;财务审批&quot;</span>) &#123;</span><br><span class="line">            tmp.<span class="built_in">changeStatus</span>(<span class="string">&quot;付款&quot;</span>);</span><br><span class="line">            log_queue.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="5-查看报销审批日志"><a href="#5-查看报销审批日志" class="headerlink" title="5. 查看报销审批日志"></a>5. 查看报销审批日志</h2><h3 id="5-1-在用户交互界面中："><a href="#5-1-在用户交互界面中：" class="headerlink" title="5.1 在用户交互界面中："></a>5.1 在用户交互界面中：</h3><p>在菜单中选择<code>6.日志展示</code>，即可打印出日志内容：</p>
<p><img src="C:\Users\WSSSJ\AppData\Roaming\Typora\typora-user-images\image-20220314174740453.png" alt="image-20220314174740453"></p>
<p><img src="C:\Users\WSSSJ\AppData\Roaming\Typora\typora-user-images\image-20220314174754443.png" alt="image-20220314174754443"></p>
<h3 id="5-2-在程序后台运行中："><a href="#5-2-在程序后台运行中：" class="headerlink" title="5.2 在程序后台运行中："></a>5.2 在程序后台运行中：</h3><p>直接调用<code>log_save</code>中的成员函数<code>display()</code>打印出日志：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">tips</span>();</span><br><span class="line">log_save.<span class="built_in">display</span>();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fin</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>





<h2 id="6-设计总结"><a href="#6-设计总结" class="headerlink" title="6. 设计总结"></a>6. 设计总结</h2><ol>
<li><p>在这次程序设计中，花费时间最久的部分为用户交互界面，即菜单的设计，我采用了<code>&lt;conio.h&gt; </code>头文件中的<code>_getch()</code>函数达到监控键盘的效果，在程序运行时，实时读取方向键上下的状态，并且同步刷新控制台界面，实现了动态的菜单效果，同时，程序在面对异常操作（乱按键盘）时，不会给予反应；</p>
</li>
<li><p>其次，在菜单的多级设计方面，我采用了函数递归回溯的方式，解决了从二级菜单返回一级菜单的问题；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">display</span>(line);</span><br><span class="line"></span><br><span class="line">        c1 = _getch();</span><br><span class="line">        <span class="keyword">if</span> (c1 == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line == <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="built_in">tips</span>();</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;系统已退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (menu_status == <span class="number">1</span>) &#123;</span><br><span class="line">                operation_status = line;</span><br><span class="line">                <span class="keyword">if</span> (line &gt; <span class="number">0</span> &amp;&amp; line &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                    menu_status = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//递归回溯</span></span><br><span class="line">                    <span class="built_in">read</span>(<span class="number">1</span>);</span><br><span class="line">                    menu_status = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">operation</span>();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                object_status = line;</span><br><span class="line">                <span class="built_in">operation</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        c2 = _getch();</span><br><span class="line">        <span class="keyword">switch</span> (c2) &#123;</span><br><span class="line">        <span class="keyword">case</span> UP: line--; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DOWN: line++; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (menu_status == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line &gt; <span class="number">8</span>)</span><br><span class="line">                line = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line &lt; <span class="number">1</span>)</span><br><span class="line">                line = <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (menu_status == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line &gt; <span class="number">4</span>)</span><br><span class="line">                line = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (line &lt; <span class="number">1</span>)</span><br><span class="line">                line = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(menu_status == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != line)</span><br><span class="line">                cout &lt;&lt; spc &lt;&lt; first[i] &lt;&lt; spc &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; arw_r &lt;&lt; first[i] &lt;&lt; arw_l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(menu_status == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != line)</span><br><span class="line">                cout &lt;&lt; spc &lt;&lt; second[i] &lt;&lt; spc &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; arw_r &lt;&lt; second[i] &lt;&lt; arw_l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数据结构设计方面，本来打算使用STL库中的容器<code>map</code>来作为表来使用，发现其红黑树的功能有些多余，于是决定手写一个简易哈希表；</p>
</li>
<li><p>有意思的两个函数：<code>tips()</code>，<code>fin()</code>：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在程序中显示“处理中...”的字样，让用户感知到操作生效的反馈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tips</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;处理中&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监视键盘，仅当读取到回车键时做出反应，可以让用户在结束一次操作之后有反应的时间，自己来决定何时返回上层菜单</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;按回车键返回上层菜单！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (c = _getch()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序的不足之处自然也是存在的，比如在处理人员报销信息时，采用的QuotaMap上的线性查找效率并不是很高，后期本来想采用二分查找，但是发现需要更改前面设计的数据结构，遂放弃，仍然采用线性查找算法；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>课设</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>求N的阶乘</title>
    <url>/2022/08/01/%E6%B1%82N%E7%9A%84%E9%98%B6%E4%B9%98/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>用递归算法，求N！的精确值(N以一般整数输入,N&lt;100)。</p>
<span id="more"></span>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入一个整数n</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出n！</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10!=3628800</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然100数据规模的阶乘是无法用longlong存下的，所以我选择用数组来模拟大数乘法，具体代码实现是从社团那里学到的，这里附上我的理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num[<span class="number">100</span>], endn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bignum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;		<span class="comment">//如果递归到1即阶乘结束</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;		<span class="comment">//temp用来存每位数做乘法之后多出来的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= endn; i++)		<span class="comment">//endn用来表示当前数组长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[i] = num[i] * n + temp;		<span class="comment">//当前位数先与n做乘法并加上上一位进位的数temp</span></span><br><span class="line">        temp = num[i] / <span class="number">10</span>;		<span class="comment">//进位的temp是当前位数与n的乘积减去个位数（数组一个单元只存一位数）</span></span><br><span class="line">        num[i] %= <span class="number">10</span>;		<span class="comment">//将乘积的个位数存进数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (temp)		<span class="comment">//如果乘完了但是temp不为0，则还需要进位</span></span><br><span class="line">    &#123;</span><br><span class="line">        num[++endn] = temp % <span class="number">10</span>;		<span class="comment">//endn需要向后扩张以保存temp</span></span><br><span class="line">        temp /= <span class="number">10</span>;			<span class="comment">//temp需要一位一位的存进数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Bignum</span>(n - <span class="number">1</span>);		<span class="comment">//递归继续与n-1相乘</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">mms</span>(num);</span><br><span class="line">        num[<span class="number">0</span>] = <span class="number">1</span>;			<span class="comment">//这里有个细节，数组的第一位需要初始化为1，否则结果将为0</span></span><br><span class="line">        <span class="built_in">Bignum</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d!=&quot;</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = endn; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            cout &lt;&lt; num[i];		<span class="comment">//逆向输出数组</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始发现long long不够用的时候，我第一反应也是用数组来模拟乘法，但是当时脑子里一直想的都是列竖式计算的时候的进位方法，也就是一位一位的去跟所有数乘，然后每次只会进一位。</p>
<p>在看了社团那边的代码之后才恍然大悟，可以每次直接用n去和数组的每一位数字相乘，多出来的数全部进位就好，不用顾忌“进位的数有好几位怎么办”这样愚蠢的问题。</p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>高精度计算</tag>
      </tags>
  </entry>
  <entry>
    <title>回型矩阵</title>
    <url>/2022/08/01/%E5%9B%9E%E5%9E%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>输出n*m的回型矩阵</p>
<span id="more"></span>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>多组测试数据<br>每组输入2个整数 n和m(不大于20)  </p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出n*m的回型矩阵，要求左上角元素是1，（每个元素占2个位置，靠右） </p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br></pre></td></tr></table></figure>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1  2  3</span><br><span class="line">10 11  4</span><br><span class="line"> 9 12  5</span><br><span class="line"> 8  7  6</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单模拟题，只用模拟出四个方向即可，我选择开一个二维数组dir用来表示四个方向；</p>
<p>在模拟过程中需要注意的问题有两个，一个是重复填数，一个是填数填到了矩阵外面，为了避免这两种情况，我在一开始将数组初始化为0，并在填数时判断当前访问单元是否越界以及是否为0（填数从1开始，所以已经被填过数的单元不为0），最后在填了n*m后break就好；</p>
<p>下面是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Map[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>, <span class="number">1</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">-1</span>, <span class="number">-1</span>,<span class="number">0</span>&#125;;		<span class="comment">//四个方向按顺序存入</span></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInMap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n &amp;&amp; !Map[i][j]) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> &amp;nowi, <span class="type">int</span> &amp;nowj, <span class="type">int</span> &amp;now, <span class="type">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mms</span>(Map);</span><br><span class="line">    Map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    nowi = <span class="number">0</span>;</span><br><span class="line">    nowj = <span class="number">0</span>;</span><br><span class="line">    now = <span class="number">0</span>;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nowi, nowj, now, num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; m &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(nowi, nowj, now, num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= m * n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isInMap</span>(nowi + dir[now][<span class="number">0</span>], nowj + dir[now][<span class="number">1</span>]))	<span class="comment">//若满足条件则填数</span></span><br><span class="line">            &#123;</span><br><span class="line">                nowi += dir[now][<span class="number">0</span>];</span><br><span class="line">                nowj += dir[now][<span class="number">1</span>];</span><br><span class="line">                Map[nowi][nowj] = num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>	<span class="comment">//若不满足条件就转向</span></span><br><span class="line">                now = ++now % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%2d%c&quot;</span>, Map[i][j], ((j == n - <span class="number">1</span>) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这道题还有另外一种解法（via. GZW）：</p>
<p>这题也可以用4个变量来记录边界位置，然后在1个大循环里面套4个小循环并在每次小循环后压缩边界来实现上面的方向模拟，若出现了边界越界则模拟结束；</p>
<p>这里面有一个小细节在于，边界变量同时作为方向模拟的初始值以及模拟结束的判断值，使得代码相对简洁；</p>
<p>下面是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> num[n][m];</span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bot = n - <span class="number">1</span>, lef = <span class="number">0</span>, rig = m - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cnt &lt;= m * n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = lef; i &lt;= rig; i++)</span><br><span class="line">                num[top][i] = cnt++;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = top; i &lt;= bot; i++)</span><br><span class="line">                num[i][rig] = cnt++;</span><br><span class="line">            rig--;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = rig; i &gt;= lef; i--)</span><br><span class="line">                num[bot][i] = cnt++;</span><br><span class="line">            bot--;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = bot; i &gt;= top; i--)</span><br><span class="line">                num[i][lef] = cnt++;</span><br><span class="line">            lef++;</span><br><span class="line">            <span class="keyword">if</span> (top &gt; bot || lef &gt; rig)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            	<span class="built_in">printf</span>(<span class="string">&quot;%2d%c&quot;</span>, num[i][j], ((j == m - <span class="number">1</span>) ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>上下车问题</title>
    <url>/2022/07/31/%E4%B8%8A%E4%B8%8B%E8%BD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n-1站），都满足此规律。</p>
<p>现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？</p>
<p>若无解则输出“No answer.”</p>
<span id="more"></span>

<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>包含多组测试数据，每组测试数据占一行，包括a，n，m和x四个数，其中0&lt;&#x3D;a，m&lt;&#x3D;100000&lt;n，x&lt;&#x3D;20</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>每组测试数据占一行，输出一个数x，即站开出时车上的人数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 6 7 3</span><br><span class="line">5 7 32 4</span><br></pre></td></tr></table></figure>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">13</span><br></pre></td></tr></table></figure>



<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本质其实就是斐波那契数列，由于每次上下车人数的计算方式不同，我选择开两个数组stops_up和stops_down，前者用来存上车人数，后者用来存下车人数；</p>
<p>上车人数的递推式为<code> stops_up[j] = stops_up[j - 1] + stops_up[j - 2];</code></p>
<p>下车人数的递推式为<code>stops_down[j] = stops_up[j-1];</code></p>
<p>由于这道题是只知道最后的下车人数但是不知道第二次的上下车人数，我决定用暴力一个个搜，即把每一种第二次上车人数的情况都给枚举出来，然后把第n-1站的人数与m比对（第m站是所有人都下车，所以m &#x3D;&#x3D; 第n-1站开出时车上的人数），如果相等则输出第x站开出时车上人数，否则无解；</p>
<p>下面是代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> scf(a) scanf(<span class="string">&quot;%d&quot;</span>, &amp;a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mms(a) memset(a, 0, sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> start, n, m, x;</span><br><span class="line"><span class="type">int</span> stops_up[MAX], stops_down[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; start &gt;&gt; n &gt;&gt; m &gt;&gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> judge = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        stops_up[<span class="number">0</span>] = start;</span><br><span class="line">        stops_down[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> summ = start, sumx = start;</span><br><span class="line">            </span><br><span class="line">            stops_up[<span class="number">1</span>] = i;</span><br><span class="line">            stops_down[<span class="number">1</span>] = i;            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                stops_up[j] = stops_up[j - <span class="number">1</span>] + stops_up[j - <span class="number">2</span>];</span><br><span class="line">                stops_down[j] = stops_up[j - <span class="number">1</span>];</span><br><span class="line">                summ += stops_up[j] - stops_down[j];	<span class="comment">//计算第j站开出时车上人数</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (j == x - <span class="number">1</span>)</span><br><span class="line">                    sumx = summ;	<span class="comment">//记录下第x站开出时车上人数</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (summ == m)</span><br><span class="line">            &#123;</span><br><span class="line">                judge = <span class="number">1</span>;</span><br><span class="line">                cout &lt;&lt; sumx &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!judge)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No answer.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>递推</tag>
      </tags>
  </entry>
</search>
